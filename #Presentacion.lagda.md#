
# Una introducci√≥n a una introducci√≥n de Agda
### Garc√≠a Fierros Nicky

## Introducci√≥n

Agda es tanto un lenguaje de programaci√≥n (funcional) como un asistente de
pruebas (Vease [PROOF = PROGRAM - Samuel Mimram](https://www.lix.polytechnique.fr/Labo/Samuel.Mimram/teaching/INF551/course.pdf). De acuerdo con la [documentaci√≥n
oficial de Agda](https://agda.readthedocs.io/en/v2.6.3/getting-started/what-is-agda.html), Agda es una extensi√≥n de la teor√≠a de tipos de Martin-L√∂f, por lo que
su poder expresivo es adecuado para escribir pruebas y especificaciones de
objetos matem√°ticos. De esta forma, Agda tambi√©n es una herramienta para la
formalizaci√≥n de las matem√°ticas. En tanto que para poder aprovechar todo el
poder de Agda como asistente de pruebas y herramienta de formalizaci√≥n de
matem√°ticas se requiere estudiar la teor√≠a de tipos antes mencionada, en esta
breve pero concisa introducci√≥n no se tocar√°n los detalle; sin embargo
considero importante mencionar que, yo como autor, el acercamiento que he
tenido con la teor√≠a de tipos de Martin-L√∂f y Agda ha sido gracias a la
teor√≠a homot√≥pica de tipos, de modo que mi forma de pensar sobre lo que se
presentar√° en este trabajo no podr√≠a empatar directamente con la teor√≠a sobre
la cual se fundamenta Agda.

Hay mucho que decir sobre la relaci√≥n entre la l√≥gica, las categor√≠as y los
tipos; sin emargo me limitar√© a mencionar la correspondencia
Curry-Howard-Lambek por muy encima, y una breve menci√≥n de tipos dependientes y
su interpretaci√≥n tanto l√≥gica como categ√≥rica.

### Correspondencia Curry-Howard-Lambek

En **[The Formulae-As-Types Notion of Construction](https://www.cs.cmu.edu/~crary/819-f09/Howard80.pdf)**, un art√≠culo escrito por el l√≥gico Alvin Howard en
1980 menicona que Curry sugiri√≥ una relaci√≥n entre los combinadores del
c√°lculo lambda y axiomas de la l√≥gica. En este mismo escrito, Howard formaliza
las observaciones hechas por Curry. Por otro lado, a inicios de los 70's el
matem√°tico Joachim Lambek demuestra que las categor√≠as cartesianas cerradas y
la l√≥gica combinatoria tipada comparten una teor√≠a ecuacional en com√∫n.

La correspondencia es entonces

|     Tipos      |     L√≥gica     |      Categor√≠as     |
| -------------  | -------------- | ------------------- |
|      ùüô         |       ‚ä§        |  Objeto terminal    |
|      ùüò         |       ‚ä•        |  Objeto inicial     |
|      ‚Üí         |       ‚äÉ        |  Flecha             |
|      √ó         |       ‚àß        |  Producto           |
|      +         |       ‚à®        |  Coproducto         |

Es importante se√±alar que, a diferencia de la teor√≠a de conjuntos, los tipos
producto y funci√≥n son conceptos primitivos.

La forma de construir t√©rminos de un tipo producto coincide con aquella de la
teor√≠a de categor√≠as. Dados $a : A$ y $b : B$ podemos construir $(a , b) : A √ó B$.
Hablaremos un poco m√°s sobre c√≥mo "acceder" a los elementos que componen un tipo
producto cuando entremos bien en materia sobre usar a Agda como un asistente de
prueba.

Por otro lado, la forma de construir un tipo flecha es mediante un proceso de
**abstracci√≥n**. Si tenemos un t√©rmino, y observamos que podemos abstraer cierto
comportamiento de inter√©s, entonces podemos introducir un tipo flecha que
abstrae el comportamiento deseado, de forma an√°loga a como solemos hacerlo en
matem√°ticas. Si, por ejemplo, observamos que la sucesi√≥n 0, 1, 2, 4, 16, 32, ...
presenta un comportamiento cuadr√°tico, podemos abstraer este comportamiento
escribiendo una representaci√≥n simb√≥lica de este en t√©rminos de nuestro lenguaje
matem√°tico:
$$
f(x) = x^2
$$

Para restringir m√°s dicho comportamiento en funci√≥n de la clase de t√©rminos que
queremos considerar en nuestra abstracci√≥n, introducimos dominios y codominios.

$$
f : ‚Ñï ‚Üí ‚Ñï
$$

de modo que s√≥lo permitimos que $f$ "funcione" con naturales, y garantizamos que
tras hacer cualquier c√≥mputo con $f$, el n√∫mero que nos devuelve es un n√∫mero
natural.

De forma an√°loga, el proceso de abstracci√≥n involucrado en la introducci√≥n
de un tipo flecha involucra un t√©rmino `t : B`, del cual abstraemos `x : A`
y garantizamos que tras cualquier c√≥mputo realizado con este tipo flecha
obtenemos otro t√©rmino de tipo `B`. Expresamos esto con la siguiente
sintaxis:

```haskell
Œªx . t : A ‚Üí B
```

### Œ†-types, Œ£-types, l√≥gica y categor√≠as.

La teor√≠a de tipos de Martin-L√∂f permite trabajar con tipos que dependen de
otros; es de esta forma que son **tipos dependientes**. Se introducen los tipos
de funciones dependientes, y los tipos coproducto.

#### Œ†-types

El HoTT Book menciona que los elementos (t√©rminos) de un tipo Œ† son funciones
cuyo tipo codominio puede variar seg√∫n el elemento del dominio hacia el cual
se aplica la funci√≥n. En virtud de este comportamiento familiar para aquellas
personas que han estudiado teor√≠a de conjuntos es que reciben el nombre de Œ†,
pues el producto cartesiano generalizado tiene este mismo comportamiento.

Dado un conjunto $A$, y una familia $B$ indizada por $A$, el producto cartesiano generalizado es
$$
\prod\limits_{a ‚àà A} B(a) = \{ f: A ‚Üí \bigcup\limits_{a ‚àà A}B(a)\ \vert\ ‚àÄa ‚àà A . f(a) ‚àà B(a) \}
$$

En teor√≠a de tipos escribimos `:` en lugar de `‚àà`, pero la sintaxis es pr√°cticamente la misma.
Dado un tipo `A`, y una familia `B:A ‚Üí Type`, podemos construir el tipo de funciones
dependientes

```haskell
Œ†(a:A) B(a) : Type
```

Intuitivamente, y en efecto as√≠ ocurre, si `B` es una familia constante, entonces

```haskell
Œ†(a:A) B(a) ‚â° (A ‚Üí B)
```

De esta forma, el tipo Œ† generaliza a los tipos flecha. Estos tipos adem√°s permiten el
polimorfismo de funciones. Una funci√≥n polimorfa es aquella que toma un tipo como
argumento y act√∫a sobre los elementos de dicho tipo. Esto deber√≠a recordarle a usted
del ‚àÄ en la l√≥gica. Una observaci√≥n pertinente es que los tipos producto se pueden
pensar como una versi√≥n "no dependiente" en cierto sentido de los tipos Œ†.

#### Œ£-types

As√≠ como los tipos Œ† generalizan a los tipos flecha, los tipos Œ£ generalizan a los
tipos producto, en tanto que permiten que el elemento en la "segunda coordenada"
dependa del elemento en la "primera coordenada". Obsevese que este comportamiento
es el mismo que permite el coproducto de la categor√≠a de conjuntos (la uni√≥n disjunta).

```haskell
Œ£(x:A) B(x)
```

Intuitivamente, y de nuevo es cierto que, si $B$ es constante, entonces
$$
\left( \sum\limits_{x : A} B \right) ‚â° (A √ó B)
$$

As√≠ como el tipo Œ† se puede identificar con el ‚àÄ en l√≥gica, el tipo Œ£ se puede
identificar con el cuantificador ‚àÉ. Una observaci√≥n adicional pertinente
respecto a los tipos Œ£ es que los tipos + son una versi√≥n "no dependiente" en
cierto sentido de los tipos Œ£.

### En resumen

Resumiendo algunos comentarios relevantes a esta peque√±a introducci√≥n a la
teor√≠a de tipos de Martin-L√∂f, tenemos la siguiente tabla.

| Tipos | L√≥gica | Categor√≠as |
| ----- | ------ | ---------- |
| Œ£     | ‚àÉ      | coproducto |
| Œ†     | ‚àÄ      | producto   |

## Probando tautolog√≠as de la l√≥gica proposicional con Agda

El poder expresivo de la teor√≠a de tipos de Martin-L√∂f (y por extensi√≥n la teor√≠a
homot√≥pica de tipos) permite identificar proposiciones matem√°ticas con tipos, y sus
demostraciones con t√©rminos de un tipo dado. De esta forma, si ocurre que el tipo
tiene por lo menos un t√©rmino, entonces podemos permitir decir que tenemos una
demostraci√≥n de dicha proposici√≥n.
En HoTT las proposiciones (de la l√≥gica proposicional) corresponden a una clase
particular de tipos, en tanto que [en la l√≥gica de primer orden no hay forma de distinguir entre una prueba de otra](https://homotopytypetheory.org/book/).
Estas tecnicalidades se mencionan con el prop√≥sito de incitar a la persona leyendo
o escuchando esto a investigar m√°s por su cuenta, pues
para prop√≥sitos de esta exposici√≥n haremos uso del tipo `Set` de Agda, que renombraremos
a `Type` para hacer √©nfasis en este paradigma de "Proposiciones como tipos".

Iniciamos escribiendo al inicio de todo nuestro archivo con extensi√≥n `.agda` o `.lagda.md`
las siguientes cl√°usulas:

```agda

open import Data.Product renaming (_√ó_ to _‚àß_)

Type = Set

```

En la primera l√≠nea le pedimos a Agda por favor y con mucho cari√±o que de la
biblioteca est√°ndar importe el tipo Product y que adem√°s renombre el operador `√ó`
a `‚àß`. En la segunda l√≠nea renombramos al tipo `Set` como `Type`.

Para pedirle a Agda, de nuevo por favor y con mucho cari√±o, que nos diga si
lo que hemos escrito hasta el momento est√° bien escrito y bien tipado
presionamos la combinaci√≥n `C-c C-l` en emacs o en vscode con la extensi√≥n `agda-mode`.
Si todo est√° bien, deber√≠amos ver colorcitos en el c√≥digo Agda que escribimos y
ning√∫n mensaje al fondo de emacs o de vscode.

Ya con nuestro pre√°mbulo listo, empecemos a demostrar pero no sin antes dar el cr√©dito
correspondiente. La gran mayor√≠a de cosas que se expondr√°n a continuaci√≥n fueron tomadas
de las siguientes fuentes:

  * [Propositional Logic in Agda - Samuel Mimram](https://www.lix.polytechnique.fr/Labo/Samuel.Mimram/teaching/INF551/TD/5.propositional.html)
  * [The HoTT Game](https://homotopytypetheory.org/2021/12/01/the-hott-game/)
  * [Agda in a hurry - Martin Escard√≥](https://www.cs.bham.ac.uk/~mhe/fp-learning-2017-2018/html/Agda-in-a-Hurry.html)
  * [HoTTEST School Agda Notes - Martin Escard√≥](https://martinescardo.github.io/HoTTEST-Summer-School/)
  * [HoTT UF in Agda - Martin Escard√≥](https://www.cs.bham.ac.uk/~mhe/HoTT-UF-in-Agda-Lecture-Notes/HoTT-UF-Agda.html#contents)
  *[Proof = Program - Samuel Mimram](https://www.lix.polytechnique.fr/Labo/Samuel.Mimram/teaching/INF551/course.pdf)

#### Proposici√≥n
Sean $A, B$ proposiciones. Entonces $A ‚àß B ‚áî B ‚àß A$.

##### Demostraci√≥n

Recordando que bajo nuestro paradigma en uso las proposiciones son tipos,
codificamos nuestra proposici√≥n como un tipo y, para demostrar la proposici√≥n
buscamos definir un t√©rmino bien tipado del tipo de nuestra proposici√≥n.

```haskell
‚àß-comm : {A B : Type} ‚Üí A ‚àß B ‚Üí B ‚àß A
‚àß-comm = Ôºü 

```

Como no sabemos ni p√≠o de Agda, le preguntamos a Agda qu√© opina que deber√≠a
ser la definici√≥n de nuestro t√©rmino que, a final de cuentas ser√° nuestra
prueba. Esto lo hacemos escribiendo el signo de interrogaci√≥n despues de el signo
de igualdad. Si le pedimos a Agda que verifique si nuestro programa est√° bien tipado,
apareceran mensajes en la parte de abajo de emacs/vscode y los s√≠mbolos `{ }0` en
donde hab√≠amos puesto nuestro preciado s√≠mbolo de interrogaci√≥n. Estos s√≠mbolos
significan que ah√≠ hay un **hueco de meta**.
Los mensajes leen

```haskell
?0 : A ‚àß B ‚Üí B ‚àß A
```

Lo que denotan los s√≠mbolos `?0` es que nuestra meta `0` es la de producir un t√©rmino
del tipo `A ‚àß B ‚Üí B ‚àß A`. Podemos pedirle a Agda que nos de m√°s informaci√≥n sobre nuestro
problema (Contexto y Meta) al posicionar el cursor en el hueco de meta
mediante la combinaci√≥n de teclas `C-c C-,` en emacs.

Veremos que ahora nos muestra mensajes muy distintos a los anteriores.
Nos dice que en nuestra declaraci√≥n del t√©rmino que necesitamos debemos asumir que
`B` y `A` son tipos. Quiz√°s para esta situaci√≥n no es muy reveladora la informaci√≥n
que brinda Agda, pero en otras situaciones brinda informaci√≥n bastante √∫til.

Podemos pedirle a Agda que nos de m√°s pistas, con base en la naturaleza de los
t√©rminos de los tipos que queremos producir. Para esto, de nuevo con el cursor en el hueco
de meta, presionamos la combinaci√≥n de teclas `C-c C-r` en emacs/vscode para "refinar la meta".

```haskell

‚àß-comm : {A B : Type} ‚Üí A ‚àß B ‚Üí B ‚àß A
‚àß-comm = Œª x ‚Üí {¬†}1

```

Al hacer esto, notamos que agda modifica el hueco y las metas se modifican acordemente.
Ahora nuestra meta es producir un t√©rmino de tipo `B ‚àß A`. Si volvemos a pedirle a Agda
el contexto y meta del problema, veremos que ahora tenemos a nuestra disposici√≥n
un t√©rmino `x : A ‚àß B`, con el cual podemos producir un t√©rmino de tipo `B ‚àß A`.
Si de nuevo le pedimos a Agda que refine la meta, tendremos ahora dos metas nuevas:
producir un t√©rmino de tipo `B` y otro t√©rmino de tipo `A`.

```haskell

‚àß-comm : {A B : Type} ‚Üí A ‚àß B ‚Üí B ‚àß A
‚àß-comm = Œª x ‚Üí {¬†}1 , {¬†}2

```

```haskell

‚àß-comm : {A B : Type} ‚Üí A ‚àß B ‚Üí B ‚àß A
‚àß-comm = Œª x ‚Üí {aa}0, {aa}1 

```

De aqu√≠, podemos proceder de al menos tres formas distintas.
  * Podemos recordar que en la teor√≠a de tipos de Martin-L√∂f (MLTT) el tipo producto
  es una noci√≥n primitiva, y por lo tanto Agda debe de implementar de forma "nativa"
  un eliminador izquierdo y derecho para el tipo producto.

  * Podemos probar un lema (redundante bajo la observaci√≥n anterior)
  * Podemos aprovechar las bondades de Agda y su pattern matching para poder construir el t√©rmino
  que queremos en virtud de la sintaxis que tienen los t√©rminos del tipo producto.

En tanto que para lo primero habr√≠a que irse a la documentaci√≥n de Agda, y podr√≠amos
usar lo tercero para probar el lema de la segunda opci√≥n, mejor probamos juntos el lema
y las otras opciones se quedan como ejercicio.

En MLTT, los t√©rminos del tipo producto se forman seg√∫n el siguiente juicio:

```haskell

Œì ‚ä¢ a : A      Œì ‚ä¢ b : B
--------------------------[√ó-intro]
Œì ‚ä¢ (a , b) : A √ó B

```

De esta forma, aprovechando el pattern matching de Agda podemos escribir la siguiente demostraci√≥n
para el lema

#### Lema

Sean $A$, $B$ proposiciones. Entonces $A ‚àß B ‚äÉ A$ y $A ‚àß B ‚äÉ B$.


##### Demostraci√≥n

```agda
‚àß-el : {A B : Type} ‚Üí A ‚àß B ‚Üí A
‚àß-el (a , b) = a

‚àß-er : {A B : Type} ‚Üí A ‚àß B ‚Üí B
‚àß-er (a , b) = b

```
Una observaci√≥n pertinete es que al refinar y obtener los dos huecos anteriormente,
Agda nos est√° diciendo que utilicemos la regla de introducci√≥n del tipo producto, tal y como
lo hicimos al probar nuestro lema, para generar el t√©rmino que deseamos. Entonces el proceso de
refinamiento de meta corresponde a aplicar una regla de introducci√≥n.

Ya armados con nuestro lema, podemos demostrar lo que quer√≠amos en un inicio.
Para "darle" a Agda los t√©rminos tenemos dos opciones, que realmente son la misma:
  * Escribir sobre el hueco el t√©rmino y luego presionar `C-c C-SPC` √≥,
  * Presionar sobre el hueco `C-c C-SPC`.

Antes de rellenar ambos huecos, prueba usando la combinaci√≥n `C-c C-n`
en alguno de los huecos, y escribiendo `‚àß-er x` o `‚àß-el x`. Encontrar√°s que Agda
**normaliza** el t√©rmino que escribiste. Al escribir `‚àß-er x` regresa `proj‚ÇÇ x` el cual
es el resultado de aplicar el eliminador "nativo" del tipo producto sobre el t√©rmino `x`.
Tras darle a Agda los t√©rminos necesarios, terminamos nuestra prueba. 

```agda

‚àß-comm : {A B : Type} ‚Üí A ‚àß B ‚Üí B ‚àß A
‚àß-comm = Œª x ‚Üí (‚àß-er x) , (‚àß-el x) 

```

En conclusi√≥n, el termino `‚àß-comm = Œª x ‚Üí (‚àß-er x) , (‚àß-el x)` es prueba/testigo de que
el tipo `‚àß-comm : {A B : Type} ‚Üí A ‚àß B ‚Üí B ‚àß A` no es vac√≠o y por lo tanto es una proposici√≥n
"verdadera".

Notemos que esta demostraci√≥n tiene su contraparte categ√≥rica.
# TODO: Insertar dibujin

Y tambi√©n tiene su contraparte en el c√°lculo de secuentes.
![secuentes conmut](./img/secuentes_comm.png)

#### Proposici√≥n

Sean $A, B$ proposiciones. Entonces $A ‚äÉ B ‚äÉ A$

##### Demostraci√≥n

```agda

prop1 : {A B : Type} ‚Üí A ‚Üí B ‚Üí A
prop1 = Œª a ‚Üí (Œª b ‚Üí a)

```

#### Proposici√≥n

Sean $A, B, C$ proposiciones. Si $A ‚äÉ B$ y $B ‚äÉ C$ entonces $A ‚äÉ C$.

##### Demostraci√≥n

```agda
-- Si uno tiene muchas ganas,
-- puede escribir la proposici√≥n en notaci√≥n de c√°lculo de secuentes

‚Üí-trans : {A B C : Type}
          ‚Üí (A ‚Üí B)
          ‚Üí (B ‚Üí C)
          ------------
          ‚Üí (A ‚Üí C)

‚Üí-trans f g = Œª a ‚Üí g (f a)
```
#### Proposici√≥n

Sea $A$ una proposici√≥n. Entonces $A ‚äÉ A$.

##### Demostraci√≥n

```agda
id : {A : Type} ‚Üí A ‚Üí A

id = Œª a ‚Üí a

```

#### Proposici√≥n

Sean $A, B$ proposiciones. Si $A ‚äÉ B$ y $A$, entonces $B$.

##### Demostraci√≥n

```agda
‚Üíapp : {A B : Type}
     ‚Üí (A ‚Üí B)
     ‚Üí A
     ----------------[App/Modus Ponens]
     ‚Üí B

‚Üíapp f a = f(a)
```

#### Proposici√≥n
Sea $A$ una proposici√≥n. Entonces $A ‚äÉ A ‚àß A$.

##### Demostraci√≥n

```agda

Œî : {A : Type}
  ‚Üí A
  -------------
  ‚Üí (A ‚àß A)


Œî a = id a , id a
```

#### Proposici√≥n
Sean $A, B, C$ proposiciones. Entonces $A √ó B ‚äÉ C$ si y solo si $A ‚äÉ B ‚äÉ C$
(Hom(A √ó B, C) ‚âÖ Hom(A, C·¥Æ))
##### Demostraci√≥n

```agda

currying : {A B C : Type}
          ‚Üí (A ‚àß B ‚Üí C)
          ----------------
          ‚Üí A ‚Üí B ‚Üí C
currying = Œª f ‚Üí Œª a ‚Üí Œª b ‚Üí f (a , b)

currying2 : {A B C : Type}
          ‚Üí (A ‚Üí B ‚Üí C)
          ----------------
          ‚Üí (A ‚àß B ‚Üí C)
currying2 = Œª f ‚Üí Œª ab ‚Üí (f (‚àß-el ab)) (‚àß-er ab) 

```

Podemos definir el si y solo si.

```agda

_‚áî_ : (A B : Type) ‚Üí Type 
A ‚áî B = (A ‚Üí B) ‚àß (B ‚Üí A)

```
#### Proposici√≥n

Sean $A, B, C$ proposiciones. Entonces $A ‚äÉ (B ‚àß C) ‚áî ((A ‚äÉ B) ‚àß (A ‚äÉ C)) 

##### Demostraci√≥n

Para probar una doble implicaci√≥n necesitamos dar una prueba de la ida y una prueba del regreso.
Para probar la ida podemos suponer que disponemos de un t√©rmino del tipo t‚ÇÅ : (A ‚Üí (B ‚àß C)) y
debemos construir un t‚ÇÇ : ((A ‚Üí B) ‚àß (A ‚Üí C)).
Para demostrar el regreso, debemos suponer que conamos con un t√©rmino t‚ÇÅ : ((A ‚Üí B) ‚àß (A ‚Üí C))
y construir un t‚ÇÇ : (A ‚Üí (B ‚àß C))

```agda
‚Üí-dist‚àß : {A B C : Type} ‚Üí (A ‚Üí (B ‚àß C)) ‚áî ((A ‚Üí B) ‚àß (A ‚Üí C))
‚Üí-dist‚àß = (Œª t‚ÇÅ ‚Üí                                            -- ‚äÉ )
                (Œª a ‚Üí ‚àß-el (t‚ÇÅ a)) , Œª a ‚Üí ‚àß-er (t‚ÇÅ a)) ,
          Œª t‚ÇÅ ‚Üí                                             -- ‚äÇ )
                Œª a ‚Üí (‚àß-el t‚ÇÅ) a , (‚àß-er t‚ÇÅ) a

```

### Disjunci√≥n

La disjunci√≥n es un tipo inductivo.

```agda
-- Cuando se tiene algo de la forma (A B : Type) estamos diciendole a Agda que queremos
-- explicitos los tipos. Cuando se tiene algo de la forma {A B : Type} le pedimos a agda
-- que infiera los tipos.

data _‚à®_ (A B : Type) : Type where
  left  : A ‚Üí A ‚à® B
  right : B ‚Üí A ‚à® B

```

Muchas veces, cuando un tipo suma est√° involucrado, es necesario separar por casos.
Esto se aprecia en la definici√≥n del tipo ‚à®, en tanto que un t√©rmino de dicho tipo
en principio puede tener dos formas: dicho t√©rmino pudo haber sido construido
mediante una aplicaci√≥n de `left`, o mediante una aplicaci√≥n de `right`. Por consiguiente,
debemos tomar en cuenta estos dos casos distintos en nuestras pruebas.

```agda

--{ Principio de demostraci√≥n por casos }--

caseof : {A B C : Type}
         ‚Üí (A ‚à® B)
         ‚Üí (A ‚Üí C)
         ‚Üí (B ‚Üí C)
         ----------------[‚à®-elim]
         ‚Üí C
 
caseof (left a‚à®b) c‚ÇÅ c‚ÇÇ = c‚ÇÅ a‚à®b     -- Caso 1. Ocurre A
caseof (right a‚à®b) c‚ÇÅ c‚ÇÇ = c‚ÇÇ a‚à®b    -- Caso 2. Ocurre B

```

#### Proposici√≥n

La disjunci√≥n es conmutativa.

##### Demostraci√≥n

```agda

‚à®-comm : {A B : Type} ‚Üí A ‚à® B ‚Üí B ‚à® A
‚à®-comm (left a‚à®b) = right a‚à®b
‚à®-comm (right a‚à®b) = left a‚à®b

```
#### Proposici√≥n

La disjunci√≥n distribuye sobre la conjunci√≥n.

##### Demostraci√≥n

```agda

‚à®-dist‚àß : {A B C : Type}
          ‚Üí (A ‚à® (B ‚àß C))
          -------------------
          ‚Üí (A ‚à® B) ‚àß (A ‚à® C)

‚à®-dist‚àß (left a‚à®[b‚àßc]) = left a‚à®[b‚àßc] , left a‚à®[b‚àßc] 
‚à®-dist‚àß (right a‚à®[b‚àßc]) = right (‚àß-el a‚à®[b‚àßc]) , right (‚àß-er a‚à®[b‚àßc])
```

### Negaci√≥n

En la l√≥gica proposicional, una proposici√≥n falsa es aquella que no se puede demostrar.
Por lo tanto, la definimos como tal.

```agda

data ‚ä• : Type where

-- su contraparte es ‚ä§, el tipo cuyo s√≥lo tiene un t√©rmino.
data ‚ä§ : Type where
  ‚ãÜ : ‚ä§

```

Observa que no tiene constructor alguno. Por lo tanto no hay forma de construir un t√©rmino
de ‚ä•.

#### Principio de explosi√≥n

Si $A$ es una proposici√≥n, entonces $‚ä• ‚äÉ A$.

#### Demostraci√≥n

```agda

‚ä•-e : {A : Type}
      ‚Üí ‚ä•
      -------------
      ‚Üí A

‚ä•-e ()
```

Donde () es una "funci√≥n vac√≠a".

La negaci√≥n de una proposici√≥n es un operador que recibe una proposici√≥n
y nos regresa otra proposici√≥n.

```agda
¬¨ : Type ‚Üí Type
¬¨ T = T ‚Üí ‚ä•
```

#### Proposici√≥n
Sean $A, B$ proposiciones. Si $A ‚äÉ B$ y $¬¨B$, entonces $¬¨A$.

##### Demostraci√≥n

```agda
¬¨impl : {A B : Type}
        ‚Üí (A ‚Üí B)
        ‚Üí ¬¨ B
        -------------
        ‚Üí ¬¨ A

¬¨impl a‚Üíb ¬¨b a = ¬¨b(‚Üíapp a‚Üíb a)

```

#### Proposici√≥n
Sea $P$ una proposici√≥n. Entonces $¬¨(P ‚àß ¬¨P)$.

##### Demostraci√≥n

```agda

no-contr : {P : Type}
           -----------
           ‚Üí ¬¨(P ‚àß ¬¨ P)

no-contr p‚àß¬¨p = ‚àß-er p‚àß¬¨p (‚àß-el p‚àß¬¨p)

```
Nuestra prueba refleja la siguiente deducci√≥n.

```haskell
 {P : Type}
 ‚ä¢ P ‚àß ¬¨ P
 -----------
 ‚ä¢ ‚ä•
```
pero eso es justo lo que nos pide la definici√≥n de la negaci√≥n.

#### Proposici√≥n

Sea $A$ una proposici√≥n. Entonces $A ‚äÉ ¬¨(¬¨ A)$.

##### Demostraci√≥n

```agda
¬¨¬¨I : {A : Type}
      ‚Üí A
      -----------
      ‚Üí ¬¨(¬¨ A)
¬¨¬¨I a = Œª ¬¨a ‚Üí ‚Üíapp ¬¨a a
```

#### Proposici√≥n

Sean $A, B$ proposiciones. Si $¬¨A$ y $A$ entonces $B$.

##### Demostraci√≥n

```agda
-- Observa que por currying da igual escribir "¬¨A" y "A" a escribir
-- ¬¨A ‚äÉ A.

¬¨e : {A B : Type}
     ‚Üí ¬¨ A
     ‚Üí A
     --------------
     ‚Üí B

¬¨e ¬¨a a = ‚ä•-e (‚Üíapp ¬¨a a)

```

#### Proposici√≥n

Sean $A, B$ proposiciones. Entonces
  
  * $(¬¨ A ‚àß ¬¨ B) ‚äÉ ¬¨ (A ‚à® B)$
  * $¬¨ (A ‚à® B) ‚äÉ (¬¨ A ‚àß ¬¨ B)$
  * $(¬¨ A ‚à® ¬¨ B) ‚äÉ ¬¨ (A ‚àß B)$
  * $¬¨ (A ‚àß B) ‚äÉ (¬¨ A ‚à® ¬¨ B)$
  
##### Demostraci√≥n

```agda
¬¨‚àß¬¨‚Üí¬¨‚à® : {A B : Type}
         ‚Üí ¬¨ A ‚àß ¬¨ B
         -----------
         ‚Üí ¬¨ (A ‚à® B)

¬¨‚àß¬¨‚Üí¬¨‚à® ¬¨a‚àß¬¨b a‚à®b = caseof a‚à®b (‚àß-el ¬¨a‚àß¬¨b) (‚àß-er ¬¨a‚àß¬¨b) 
¬¨‚à®‚Üí¬¨‚àß¬¨ : {A B : Type}
         ‚Üí ¬¨ (A ‚à® B)
         ------------
         ‚Üí ¬¨ A ‚àß ¬¨ B

¬¨‚à®‚Üí¬¨‚àß¬¨ ¬¨[a‚à®b] = (Œª a ‚Üí ‚Üíapp ¬¨[a‚à®b] (left a)) , Œª b ‚Üí ‚Üíapp ¬¨[a‚à®b] (right b)

¬¨‚à®¬¨‚Üí¬¨‚àß : {A B : Type}
         ‚Üí ¬¨ A ‚à® ¬¨ B
         ------------
         ‚Üí ¬¨ (A ‚àß B)
         
¬¨‚à®¬¨‚Üí¬¨‚àß ¬¨a‚à®¬¨b a‚àßb = caseof ¬¨a‚à®¬¨b
                   (Œª ¬¨a ‚Üí
                         ‚Üíapp ¬¨a (‚àß-el a‚àßb))
                   Œª ¬¨b ‚Üí
                        ‚Üíapp ¬¨b (‚àß-er a‚àßb)

-- ¬¨‚àß‚Üí¬¨‚à®¬¨' : {A B : Type}
--      ‚Üí ¬¨ (A ‚àß B)
--      -------------
--      ‚Üí (¬¨ A ‚à® ¬¨ B)

-- ¬¨‚àß‚Üí¬¨‚à®¬¨' ¬¨a‚àßb = ?


```

### Matem√°ticas no constructivas

#### La Ley del Tercer Excluido y la doble negaci√≥n.

El marco te√≥rico bajo el cual trabaja Agda est√° basado en la l√≥gica
intuicionista. En virtud de la equivalencia de implicaci√≥n
$$
¬¨(A ‚àß B) ‚äÉ ¬¨A ‚à® ¬¨B
$$
con el lema del tercer excluido:
$$
A ‚à® ¬¨A ‚äÉ ‚ä§
$$
no podemos terminar de demostrar las equivalencias de De Morgan. Si en verdad
queremos con toda nuestra alma emplear el lema del tercer excluido,
podemos introducirlo como un postulado de la siguiente forma:

  * [README.Case](http://agda.github.io/agda-stdlib/README.Case.html#1) 

```agda

postulate LEM : {A : Type} ‚Üí  A ‚à® ¬¨ A

lemma1 : {A : Type} ‚Üí ¬¨ (¬¨ (¬¨ A)) ‚Üí ¬¨ A
lemma1 ¬¨[¬¨¬¨a] a = ‚Üíapp ¬¨[¬¨¬¨a] (¬¨¬¨I a)

dnn : {A : Type}
      ‚Üí ¬¨(¬¨ A)
      ----------
      ‚Üí A

dnn {A} ¬¨¬¨a = caseof LEM
              (Œª a ‚Üí a) -- sup A
              Œª ¬¨a ‚Üí ‚ä•-e (¬¨e ¬¨¬¨a ¬¨a) -- sup ¬¨A

```

¬øPuedes probar la equivalencia de DeMorgan restante con estas herramientas
no constructivas?

```agda
-- ¬¨‚àß‚Üí¬¨‚à®¬¨ : {A B : Type}
--      ‚Üí ¬¨ (A ‚àß B)
--      -------------
--      ‚Üí ¬¨ A ‚à® ¬¨ B

-- ¬¨‚àß‚Üí¬¨‚à®¬¨ = ? 

```

## Enunciados con predicados: una introducci√≥n a los tipos dependientes

En esta secci√≥n codificaremos a los n√∫meros naturales en Agda y demostraremos
algunas propiedades sobre los objetos que vayamos construyendo.

#### Definici√≥n

Una familia de tipos es una funci√≥n que manda t√©rminos en tipos.

##### Ejemplo

```agda

data Bool : Type where
  true : Bool
  false : Bool

-- D es una familia de tipos indizada por Bool.

D : Bool ‚Üí Type
D true = Bool
D false = ‚ä•

--- Los tipos dependientes nos permiten definir familias de funciones para cada Tipo
--- Esto se conoce como polimorfismo

-- Observa que esta funci√≥n recibe como par√°metro una familia de tipos (X : Bool ‚Üí Type)
-- "Para todo b : Bool, define c√≥mo se comporta X b".
if[_]_then_else_ : (X : Bool ‚Üí Type)
                   ‚Üí (b : Bool)
                   ‚Üí X true
                   ‚Üí X false
                   ‚Üí X b

-- si b es true, entonces act√∫a seg√∫n la familia en true.
if[ X ] true then x else y = x
-- si b es false, entonces act√∫a seg√∫n la familia en false.
if[ X ] false then x else y = y

```

$$
  \prod\limits_{b : Bool} D(b)
$$

Definimos a los n√∫meros naturales como un *tipo inductivo**.

```agda

data ‚Ñï : Type where
  zero : ‚Ñï
  suc  : ‚Ñï ‚Üí ‚Ñï

```
La definici√≥n es inductiva:
  * La clausula base      : `zero` es un t√©rmino de ‚Ñï
  * La clausula inductiva : si `t : ‚Ñï` entonces `suc t : ‚Ñï`.

Por conveniencia y eficiencia, le pedimos a Agda que utilice los s√≠mbolos con los que
estamos familiarizados para denotar a los n√∫meros naturales en lugar de escribir
`suc (suc (suc ‚Ä¶ (suc zero) ‚Ä¶ ))` para denotar a un n√∫mero.

```agda

{-# BUILTIN NATURAL ‚Ñï #-}

```

Con la instrucci√≥n anterior, Agda se apoya en la implementaci√≥n de los n√∫meros
naturales con la que viene Haskell.

Ya con otro tipo m√°s interesante, podemos jugar con nuestra funci√≥n anterior

```agda
fam : Bool ‚Üí Type
fam true = ‚Ñï
fam false = Bool

fun : (b : Bool) ‚Üí fam b
fun b = if[ fam ] b then 6 else false

-- Podemos permitir que los tipos que devuelve una funci√≥n no sean los mismos :D
```

Ya que estamos un poco m√°s familiarizados con los tipos dependientes codifiquemos
el principio de inducci√≥n matem√°tica en Agda para n√∫meros naturales.

### Principio de Inducci√≥n

Sea $œÜ$ una propiedad de los n√∫meros naturales. Si $œÜ(0)$ y $œÜ(n) ‚äÉ œÜ(n+1)$ entonces
$‚àÄ k ‚àà ‚Ñï : œÜ(k)$.

-------------

Para codificar una propiedad de los n√∫meros naturales arbitraria, podemos hacerlo
con una familia de tipos indizada sobre ‚Ñï, de modo que `{œÜ : ‚Ñï ‚Üí Type}` jugar√° el papel
de una propiedad sobre ‚Ñï. Luego, necesitamos construir dos t√©rminos en virtud de lo que
queremos demostrar: un t√©rmino para œÜ(0); `œÜ 0`; y un t√©rmino para œÜ(n) ‚äÉ œÜ(n+1);
`(n : ‚Ñï) ‚Üí œÜ n ‚Üí œÜ (suc n)`; esto se puede leer como "$‚àÄ n ‚àà ‚Ñï . (œÜ(n) ‚äÉ œÜ(n+1))$".
Nuestra meta entonces es construir un t√©rmino o testigo de
`(k : ‚Ñï) ‚Üí œÜ n`; que se puede leer como "$‚àÄ k ‚àà ‚Ñï . œÜ(k)$".

> Nota sobre la notaci√≥n: [agda function-types](https://agda.readthedocs.io/en/v2.5.2/language/function-types.html)

```agda

‚Ñï-elim : {œÜ : ‚Ñï ‚Üí Type}
         ‚Üí œÜ zero
         ‚Üí ((n : ‚Ñï) ‚Üí œÜ n ‚Üí œÜ (suc n))
         ------------------------------
         ‚Üí ‚àÄ (k : ‚Ñï) ‚Üí œÜ k                 ---- Es lo mismo que s√≥lo escribir (k : ‚Ñï) ‚Üí œÜ k pero
                                           ---- se ve perron jajaja (TODO Borrar esto jaja)

---- Sup. que ocurren las dos hip√≥tesis.
---- Queremos construir un testigo de la conclusi√≥n a partir de estas hip.

-- ‚Ñï-elim {œÜ} œÜ‚ÇÄ f = h                        
--   where
--    h : (n : ‚Ñï) ‚Üí œÜ n
--    h n = ?
-- hacemos casos sobre n, en tanto que n ‚àà ‚Ñï implica que n es zero o es sucesor de alguien.

‚Ñï-elim {œÜ} œÜ‚ÇÄ f = h
  where
    h : ‚àÄ (n : ‚Ñï) ‚Üí œÜ n
    h zero = œÜ‚ÇÄ
    h (suc k) = f k HI        ----- Alternativamente, h (suc k) f k (h k)
      where
        HI : œÜ k        ----------- la HI nos da informaci√≥n sobre c√≥mo fue construida la
        HI = h k        ----------- evidencia de œÜ hasta k. Recordar que œÜ : ‚Ñï ‚Üí Type es una fam.
                        ---- Es recursivo el asunto. Para verificar h (suc k), verfica h k, y
                        ---- as√≠ te vas hasta h zero, y luego te subes de regreso a h (suc k).
-- ‚Ñï-elim {œÜ} œÜ‚ÇÄ f = h                        
--   where
--    h : (n : ‚Ñï) ‚Üí œÜ n
--    h zero = œÜ‚ÇÄ      --- La evidencia de que œÜ zero ocurre es una hip√≥tesis.


    --- La evidencia de que sabemos c√≥mo producir una prueba para suc n est√° codificada
    --- en nuestra hip√≥tesis.

    --- Agda nos pide œÜ (suc n). Notamos que podemos producir un t√©rmino de este tipo
    --- a partir de nuestra hip√≥tesis f. Para aplicar dicha hip√≥tesis necesitamos
    --- un t√©rmino de tipo (n‚ÇÅ : ‚Ñï) ‚Üí œÜ n‚ÇÅ
--    h (suc n) = f n HI
--      where
--        HI : œÜ n
--        HI = h n
```

Una prueba m√°s elegante:

```agda

Nat-elim : {œÜ : ‚Ñï ‚Üí Type}
           ‚Üí œÜ 0
           ‚Üí ((k : ‚Ñï) ‚Üí œÜ k ‚Üí œÜ (suc k))
           --------------------------------
           ‚Üí (n : ‚Ñï) ‚Üí œÜ n


Nat-elim {œÜ} œÜ‚ÇÄ f zero = œÜ‚ÇÄ
Nat-elim {œÜ} œÜ‚ÇÄ f (suc x) = f x (Nat-elim œÜ‚ÇÄ f x)
    
```

De acuerdo con Martin Escard√≥, esta es la √∫nica definici√≥n recursiva en toda la teor√≠a
de tipos de Martin L√∂f. Cualquier otra llamada recursiva tiene que ser propia de la
regla de eliminaci√≥n del tipo inductivo.

Ahora que ya tenemos nuestro tipo de n√∫meros naturales y una forma de hacer inducci√≥n
sobre estos, utilicemos estas construcciones para demostrar cosas sobre ‚Ñï.

### La suma, el producto y el orden en ‚Ñï

Definimos la suma de forma inductiva.

#### Definici√≥n:

La suma en ‚Ñï se define como a continuaci√≥n.

```agda

_+_ : ‚Ñï ‚Üí ‚Ñï ‚Üí ‚Ñï
-- casos en m en m + n = ?
zero + zero = zero
zero + suc n = suc n
suc m + zero = suc m
suc m + suc n = suc (suc (m + n))

_¬∑_ : ‚Ñï ‚Üí ‚Ñï ‚Üí ‚Ñï

zero ¬∑ n = zero
(suc m) ¬∑ n = (m ¬∑ n) + n

_‚â§_ : ‚Ñï ‚Üí ‚Ñï ‚Üí Type
zero ‚â§ y = ‚ä§
suc x ‚â§ zero = ‚ä•
suc x ‚â§ suc y = HI
  where
    HI : Type
    HI = x ‚â§ y
```
[nat_sum]!(/Users/nicky/Working Directory/Servicio Social/PresentacionAgda/nat_sum_conm.png)

### Una introducci√≥n al tipo identidad.

La igualdad entre dos objetos matem√°ticos generalmente es una proposici√≥n.
Si los objetos en cuesti√≥n satisfacen nuestra definici√≥n de igualdad, entonces
podemos dar una prueba de dicha igualdad; la experiencia muestra que esto no siempre
es trivial; en otro caso, no podemos dar prueba de este hecho.

Para decidir la igualdad entre dos n√∫meros naturales, por construcci√≥n necesitamos
verificar tres casos:

  * ambos son cero
  * alguno de los dos son cero
  * sus sucesores son iguales.

Entonces, dados dos n√∫meros naturales, siguiendo nuestro paradigma de proposiciones como tipos,
definimos el tipo igualdad de dos n√∫meros naturales.

```agda

_‚â°'_ : ‚Ñï ‚Üí ‚Ñï ‚Üí Type
zero ‚â°' zero = ‚ä§
zero ‚â°' suc b = ‚ä• -- el cero no es sucesor de nadie
suc a ‚â°' zero = ‚ä• -- no tenemos reflexividad todavia. Mismo caso que el anterior.
suc a ‚â°' suc b = a ‚â°' b -- si sus sucesores son iguales, entonces inductivamente decidimos.

```

Existe una forma m√°s general de definir la igualdad para cualesquier tipo, y es mediante
el tipo identidad. El razonamiento b√°sico detr√°s de la definici√≥n es la siguiente:

> Bajo el paradigma de Tipos como Proposiciones, como ya se discuti√≥ antes, tiene sentido
pensar en la igualdad como un tipo m√°s. Sin embargo, queremos definir la igualdad para
cualquier tipo. ¬øC√≥mo definimos este tipo? La informaci√≥n b√°sica para decidir la igualdad
entre dos objetos es la siguiente: necesitamos la clase de objetos con los que estamos lidiando,
esto es el tipo de los objetos a comparar, a saber `T`, y necesitamos dos objetos a comparar,
esto es, `x : T` y `y : T`. Dada esta informaci√≥n, el tipo igualdad `x = y` es un tipo que
depende de los t√©rminos `x` y `y`. Por lo tanto `x = y` debe ser un tipo dependiente.
Si `p : x = y`, entonces es porque `p` es testigo de la igualdad; en otras palabras,
`p` es una identificaci√≥n de `x` y de `y`. Si `p, q : x = y`, entonces debemos poder formar
tambi√©n el tipo `p = q`. De esta forma, podemos emplear a los tipos para decir cosas sobre
la igualdad (¬øser√° que dos identificaciones tambi√©n pueden identificarse entre si?, ¬°pensar en
homotop√≠a!). Finalmente, la propiedad fundamental que satisfacen todas las nociones de igualdad
es una de reflexividad. Se codifica al tipo identidad entonces como un tipo inductivo
dependiente con un constructor que debe testificar la reflexividad, con el prop√≥sito de dotar
de estructura inductiva y de tipo con el fin de hacer m√°s rica la discusi√≥n sobre la igualdad
en la teor√≠a.

Aunque la discusi√≥n dada en esta exposici√≥n es quiz√°s un poco larga, el tema de igualdad
es uno muy rico en contenido y discusi√≥n dentro de la teor√≠a homot√≥pica de tipos. Se hace
la cordial invitaci√≥n a leer m√°s sobre el tema en las referencias.

```agda
-- Dados un tipo T, para cada dos x , y : T
-- tenemos un tipo x ‚â° y llamado tipo identidad de x a y.
data _‚â°_ {T : Type} : T ‚Üí T ‚Üí Type where
  refl : (x : T) ‚Üí x ‚â° x

-- x ‚â° y es la proposici√≥n "x = y seg√∫n T", y para cada x tenemos una prueba de que x es
-- igual a x seg√∫n T.
```
Probemos la reflexividad de ‚â°.

#### Proposici√≥n
‚â° es transitiva y sim√©trica.

##### Demostraci√≥n

```agda

‚â°-sym : ‚àÄ {T : Type} {n m : T}
        ‚Üí n ‚â° m
        -----------
        ‚Üí m ‚â° n

-- n ‚â° m fue construido como `refl n`
-- para construir m ‚â° n basta entonces hacer lo mismo, en tanto que n ‚â° m.
-- es decir, tanto m y n est√°n identificados internamente en T.
‚â°-sym (refl n) = refl n

‚â°-trans : ‚àÄ {A : Type} {x y z : A}
          ‚Üí x ‚â° y
          ‚Üí y ‚â° z
          -------------------------
          ‚Üí x ‚â° z

-- como x ‚â° y, y por hip√≥tesis y ‚â° z, entonces x y z deben estar
-- tambi√©n identificados en x ‚â° y
-- ‚â°-trans x‚â°y (refl y) = x‚â°y
‚â°-trans (refl x) (refl y) = refl x
```
Regresando a nuestras definiciones de suma, producto y orden; ya con
el tipo identidad y los tipos dependientes podemos demostrar propiedades sobre
estas operaciones.

#### Lema:
  * ‚àÄ A B : Type . ‚àÄ f : A ‚Üí B . ‚àÄ x y : T . x ‚â° y ‚áí f x ‚â° f y 
  * ‚àÄ n ‚àà ‚Ñï . n + 0 = n
  * ‚àÄ n ‚àà ‚Ñï . 0 + n = n
  * ‚àÄ n, m ‚àà ‚Ñï . n + suc m = suc (m + n)

##### Demostraci√≥n:

```agda

cong : ‚àÄ {A B : Type} (f : A ‚Üí B) {x y : A}
       ‚Üí x ‚â° y
       --------
       ‚Üí f x ‚â° f y
cong f (refl x) = refl (f x)

zero+n-=-n : ‚àÄ (n : ‚Ñï) ‚Üí (zero + n) ‚â° n
zero+n-=-n zero = refl zero
zero+n-=-n (suc n) = refl (suc n)

n+zero-=-n : ‚àÄ (n : ‚Ñï) ‚Üí (n + zero) ‚â° n
n+zero-=-n zero = refl zero
n+zero-=-n (suc n) = refl (suc n)

-- Doble inducci√≥n sobre n y m :D

+-suc : ‚àÄ (n m : ‚Ñï) ‚Üí (suc m + n) ‚â° suc (m + n)

+-suc zero m = cong suc (‚â°-sym (n+zero-=-n m))
+-suc (suc n) zero = cong suc (cong suc (zero+n-=-n n))
+-suc (suc n) (suc m) = cong suc (cong suc HI)
  where
    HI : (suc m + n) ‚â° suc (m + n)
    HI = +-suc n m
              
```

#### Proposici√≥n:
La suma en ‚Ñï es conmutativa.

##### Demostraci√≥n

```agda

+-conm : ‚àÄ (x y : ‚Ñï) ‚Üí (x + y) ‚â° (y + x)

+-conm zero y = ‚â°-sym AF4
  where
    AF1 : (zero + y) ‚â° y
    AF1 = zero+n-=-n y
    AF2 : (y + zero) ‚â° y
    AF2 = n+zero-=-n y
    AF3 : y ‚â° (zero + y)
    AF3 = ‚â°-sym AF1
    AF4 : (y + zero) ‚â° (zero + y)
    AF4 = ‚â°-trans AF2 AF3
+-conm (suc x) zero = refl (suc x)
+-conm (suc x) (suc y) = cong suc (cong suc HI)
  where
    HI : (x + y) ‚â° (y + x) 
    HI = +-conm x y

```

#### Proposici√≥n

x ‚â§ y ‚áî ‚àÉ k : ‚Ñï . x + k = y

##### Demostraci√≥n

```agda
open import Agda.Builtin.Sigma

-Œ£ = Œ£
infix 2 -Œ£
syntax -Œ£ A (Œª x ‚Üí B) = ‚àÉ x ‚àà A , B 

_~_ : ‚Ñï ‚Üí ‚Ñï ‚Üí Type

a ~ b = ‚àÉ k ‚àà ‚Ñï , (a + k) ‚â° b 

~-es-‚â§ : ‚àÄ (a b : ‚Ñï)
         ‚Üí a ‚â§ b
         -----------
         ‚Üí a ~ b

~-es-‚â§ zero zero leq1 = zero , refl zero -- `zero` es tal que testifica lo que se quiere
~-es-‚â§ zero (suc b) leq1 = suc b , refl (suc b) -- `suc b` testifica que `zero + suc b ‚â° suc b`
~-es-‚â§ (suc a) (suc b) leq1 = k , AF2
  where
    HI : ‚àÉ k ‚àà ‚Ñï , (a + k) ‚â° b
    HI = ~-es-‚â§ a b leq1

    k : ‚Ñï
    k = fst HI

    HI' : (a + k) ‚â° b
    HI' = snd HI

    AF1 : (suc a + k) ‚â° suc (a + k)
    AF1 = +-suc k a
    AF2 : (suc a + k) ‚â° suc b
    AF2 = ‚â°-trans AF1 (cong suc HI')
```

# Esto concluye la presentaci√≥n.
## ¬°Muchas gracias por su atenci√≥n!

# TODO
> Mencionar a que aplicaci√≥n de juicios corresponden las combinaciones de teclas en agda
[Agda Docs](https://agda.readthedocs.io/en/v2.5.2/tools/emacs-mode.html)
