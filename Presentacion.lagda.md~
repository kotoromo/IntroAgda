
# Una introducci√≥n a una introducci√≥n de Agda
### Garc√≠a Fierros Nicky

## Introducci√≥n

Agda es tanto un lenguaje de programaci√≥n (funcional) como un asistente de
pruebas (Vease [PROOF = PROGRAM - Samuel Mimram](https://www.lix.polytechnique.fr/Labo/Samuel.Mimram/teaching/INF551/course.pdf). De acuerdo con la [documentaci√≥n
oficial de Agda](https://agda.readthedocs.io/en/v2.6.3/getting-started/what-is-agda.html), Agda es una extensi√≥n de la teor√≠a de tipos de Martin-L√∂f, por lo que
su poder expresivo es adecuado para escribir pruebas y especificaciones de
objetos matem√°ticos. De esta forma, Agda tambi√©n es una herramienta para la
formalizaci√≥n de las matem√°ticas. En tanto que para poder aprovechar todo el
poder de Agda como asistente de pruebas y herramienta de formalizaci√≥n de
matem√°ticas se requiere estudiar la teor√≠a de tipos antes mencionada, en esta
breve pero concisa introducci√≥n no se tocar√°n los detalle; sin embargo
considero importante mencionar que, yo como autor, el acercamiento que he
tenido con la teor√≠a de tipos de Martin-L√∂f y Agda ha sido gracias a la
teor√≠a homot√≥pica de tipos, de modo que mi forma de pensar sobre lo que se
presentar√° en este trabajo no podr√≠a empatar directamente con la teor√≠a sobre
la cual se fundamenta Agda.

Hay mucho que decir sobre la relaci√≥n entre la l√≥gica, las categor√≠as y los
tipos; sin emargo me limitar√© a mencionar la correspondencia
Curry-Howard-Lambek por muy encima, y una breve menci√≥n de tipos dependientes y
su interpretaci√≥n tanto l√≥gica como categ√≥rica.

### Correspondencia Curry-Howard-Lambek

En **[The Formulae-As-Types Notion of Construction](https://www.cs.cmu.edu/~crary/819-f09/Howard80.pdf)**, un art√≠culo escrito por el l√≥gico Alvin Howard en
1980 menicona que Curry sugiri√≥ una relaci√≥n entre los combinadores del
c√°lculo lambda y axiomas de la l√≥gica. En este mismo escrito, Howard formaliza
las observaciones hechas por Curry. Por otro lado, a inicios de los 70's el
matem√°tico Joachim Lambek demuestra que las categor√≠as cartesianas cerradas y
la l√≥gica combinatoria tipada comparten una teor√≠a ecuacional en com√∫n.

La correspondencia es entonces

|     Tipos      |     L√≥gica     |      Categor√≠as     |
| -------------  | -------------- | ------------------- |
|      ùüô         |       ‚ä§        |  Objeto terminal    |
|      ùüò         |       ‚ä•        |  Objeto inicial     |
|      ‚Üí         |       ‚äÉ        |  Flecha             |
|      √ó         |       ‚àß        |  Producto           |
|      +         |       ‚à®        |  Coproducto         |

Es importante se√±alar que, a diferencia de la teor√≠a de conjuntos, los tipos
producto y funci√≥n son conceptos primitivos.

La forma de construir t√©rminos de un tipo producto coincide con aquella de la
teor√≠a de categor√≠as. Dados $a : A$ y $b : B$ podemos construir $(a , b) : A √ó B$.
Hablaremos un poco m√°s sobre c√≥mo "acceder" a los elementos que componen un tipo
producto cuando entremos bien en materia sobre usar a Agda como un asistente de
prueba.

Por otro lado, la forma de construir un tipo flecha es mediante un proceso de
**abstracci√≥n**. Si tenemos un t√©rmino, y observamos que podemos abstraer cierto
comportamiento de inter√©s, entonces podemos introducir un tipo flecha que
abstrae el comportamiento deseado, de forma an√°loga a como solemos hacerlo en
matem√°ticas. Si, por ejemplo, observamos que la sucesi√≥n 0, 1, 2, 4, 16, 32, ...
presenta un comportamiento cuadr√°tico, podemos abstraer este comportamiento
escribiendo una representaci√≥n simb√≥lica de este en t√©rminos de nuestro lenguaje
matem√°tico:
$$
f(x) = x^2
$$

Para restringir m√°s dicho comportamiento en funci√≥n de la clase de t√©rminos que
queremos considerar en nuestra abstracci√≥n, introducimos dominios y codominios.

$$
f : ‚Ñï ‚Üí ‚Ñï
$$

de modo que s√≥lo permitimos que $f$ "funcione" con naturales, y garantizamos que
tras hacer cualquier c√≥mputo con $f$, el n√∫mero que nos devuelve es un n√∫mero
natural.

De forma an√°loga, el proceso de abstracci√≥n involucrado en la introducci√≥n
de un tipo flecha involucra un t√©rmino `t : B`, del cual abstraemos `x : A`
y garantizamos que tras cualquier c√≥mputo realizado con este tipo flecha
obtenemos otro t√©rmino de tipo `B`. Expresamos esto con la siguiente
sintaxis:

```haskell
Œªx . t : A ‚Üí B
```

### Œ†-types, Œ£-types, l√≥gica y categor√≠as.

La teor√≠a de tipos de Martin-L√∂f permite trabajar con tipos que dependen de
otros; es de esta forma que son **tipos dependientes**. Se introducen los tipos
de funciones dependientes, y los tipos coproducto.

#### Œ†-types

El HoTT Book menciona que los elementos (t√©rminos) de un tipo Œ† son funciones
cuyo tipo codominio puede variar seg√∫n el elemento del dominio hacia el cual
se aplica la funci√≥n. En virtud de este comportamiento familiar para aquellas
personas que han estudiado teor√≠a de conjuntos es que reciben el nombre de Œ†,
pues el producto cartesiano generalizado tiene este mismo comportamiento.

Dado un conjunto $A$, y una familia $B$ indizada por $A$, el producto cartesiano generalizado es
$$
\prod\limits_{a ‚àà A} B(a) = \{ f: A ‚Üí \bigcup\limits_{a ‚àà A}B(a)\ \vert\ ‚àÄa ‚àà A . f(a) ‚àà B(a) \}
$$

En teor√≠a de tipos escribimos `:` en lugar de `‚àà`, pero la sintaxis es pr√°cticamente la misma.
Dado un tipo `A`, y una familia `B:A ‚Üí Type`, podemos construir el tipo de funciones
dependientes

```haskell
Œ†(a:A) B(a) : Type
```

Intuitivamente, y en efecto as√≠ ocurre, si `B` es una familia constante, entonces

```haskell
Œ†(a:A) B(a) ‚â° (A ‚Üí B)
```

De esta forma, el tipo Œ† generaliza a los tipos flecha. Estos tipos adem√°s permiten el
polimorfismo de funciones. Una funci√≥n polimorfa es aquella que toma un tipo como
argumento y act√∫a sobre los elementos de dicho tipo. Esto deber√≠a recordarle a usted
del ‚àÄ en la l√≥gica. Una observaci√≥n pertinente es que los tipos producto se pueden
pensar como una versi√≥n "no dependiente" en cierto sentido de los tipos Œ†.

#### Œ£-types

As√≠ como los tipos Œ† generalizan a los tipos flecha, los tipos Œ£ generalizan a los
tipos producto, en tanto que permiten que el elemento en la "segunda coordenada"
dependa del elemento en la "primera coordenada". Obsevese que este comportamiento
es el mismo que permite el coproducto de la categor√≠a de conjuntos (la uni√≥n disjunta).

```haskell
Œ£(x:A) B(x)
```

Intuitivamente, y de nuevo es cierto que, si $B$ es constante, entonces
$$
\right( \sum\limits_{x : A} B \left) ‚â° (A √ó B)
$$

As√≠ como el tipo Œ† se puede identificar con el ‚àÄ en l√≥gica, el tipo Œ£ se puede
identificar con el cuantificador ‚àÉ. Una observaci√≥n adicional pertinente
respecto a los tipos Œ£ es que los tipos + son una versi√≥n "no dependiente" en
cierto sentido de los tipos Œ£.

### En resumen

Resumiendo algunos comentarios relevantes a esta peque√±a introducci√≥n a la
teor√≠a de tipos de Martin-L√∂f, tenemos la siguiente tabla.

| Tipos | L√≥gica | Categor√≠as |
| ----- | ------ | ---------- |
| Œ£     | ‚àÉ      | coproducto |
| Œ†     | ‚àÄ      | producto   |

## Probando tautolog√≠as de la l√≥gica proposicional con Agda

El poder expresivo de la teor√≠a de tipos de Martin-L√∂f (y por extensi√≥n la teor√≠a
homot√≥pica de tipos) permite identificar proposiciones matem√°ticas con tipos, y sus
demostraciones con t√©rminos de un tipo dado. De esta forma, si ocurre que el tipo
tiene por lo menos un t√©rmino, entonces podemos permitir decir que tenemos una
demostraci√≥n de dicha proposici√≥n.
En HoTT las proposiciones (de la l√≥gica proposicional) corresponden a una clase
particular de tipos, en tanto que [en la l√≥gica de primer orden no hay forma de distinguir entre una prueba de otra](https://homotopytypetheory.org/book/).
Estas tecnicalidades se mencionan con el prop√≥sito de incitar a la persona leyendo
o escuchando esto a investigar m√°s por su cuenta, pues
para prop√≥sitos de esta exposici√≥n haremos uso del tipo `Set` de Agda, que renombraremos
a `Type` para hacer √©nfasis en este paradigma de "Proposiciones como tipos".

Iniciamos escribiendo al inicio de todo nuestro archivo con extensi√≥n `.agda` o `.lagda.md`
las siguientes cl√°usulas:

```agda

open import Data.Product renaming (_√ó_ to _‚àß_)

Type = Set

```

En la primera l√≠nea le pedimos a Agda por favor y con mucho cari√±o que de la
biblioteca est√°ndar importe el tipo Product y que adem√°s renombre el operador `√ó`
a `‚àß`. En la segunda l√≠nea renombramos al tipo `Set` como `Type`.

Para pedirle a Agda, de nuevo por favor y con mucho cari√±o, que nos diga si
lo que hemos escrito hasta el momento est√° bien escrito y bien tipado
presionamos la combinaci√≥n `C-c C-l` en emacs o en vscode con la extensi√≥n `agda-mode`.
Si todo est√° bien, deber√≠amos ver colorcitos en el c√≥digo Agda que escribimos y
ning√∫n mensaje al fondo de emacs o de vscode.

Ya con nuestro pre√°mbulo listo, empecemos a demostrar pero no sin antes dar el cr√©dito
correspondiente. La gran mayor√≠a de cosas que se expondr√°n a continuaci√≥n fueron tomadas
de las siguientes fuentes:

  * [Propositional Logic in Agda - Samuel Mimram](https://www.lix.polytechnique.fr/Labo/Samuel.Mimram/teaching/INF551/TD/5.propositional.html)
  * [The HoTT Game](https://homotopytypetheory.org/2021/12/01/the-hott-game/)
  * [Agda in a hurry - Martin Escard√≥](https://www.cs.bham.ac.uk/~mhe/fp-learning-2017-2018/html/Agda-in-a-Hurry.html)
  * [HoTTEST School Agda Notes - Martin Escard√≥](https://martinescardo.github.io/HoTTEST-Summer-School/)
  * [HoTT UF in Agda - Martin Escard√≥](https://www.cs.bham.ac.uk/~mhe/HoTT-UF-in-Agda-Lecture-Notes/HoTT-UF-Agda.html#contents)
  *[Proof = Program - Samuel Mimram](https://www.lix.polytechnique.fr/Labo/Samuel.Mimram/teaching/INF551/course.pdf)

#### Proposici√≥n
Sean $A, B$ proposiciones. Entonces $A ‚àß B ‚áî B ‚àß A$.

##### Demostraci√≥n

Recordando que bajo nuestro paradigma en uso las proposiciones son tipos,
codificamos nuestra proposici√≥n como un tipo y, para demostrar la proposici√≥n
buscamos definir un t√©rmino bien tipado del tipo de nuestra proposici√≥n.

```haskell
‚àß-comm : {A B : Type} ‚Üí A ‚àß B ‚Üí B ‚àß A
‚àß-comm = Ôºü 

```

Como no sabemos ni p√≠o de Agda, le preguntamos a Agda qu√© opina que deber√≠a
ser la definici√≥n de nuestro t√©rmino que, a final de cuentas ser√° nuestra
prueba. Esto lo hacemos escribiendo el signo de interrogaci√≥n despues de el signo
de igualdad. Si le pedimos a Agda que verifique si nuestro programa est√° bien tipado,
apareceran mensajes en la parte de abajo de emacs/vscode y los s√≠mbolos `{ }0` en
donde hab√≠amos puesto nuestro preciado s√≠mbolo de interrogaci√≥n. Estos s√≠mbolos
significan que ah√≠ hay un **hueco de meta**.
Los mensajes leen

```haskell
?0 : A ‚àß B ‚Üí B ‚àß A
```

Lo que denotan los s√≠mbolos `?0` es que nuestra meta `0` es la de producir un t√©rmino
del tipo `A ‚àß B ‚Üí B ‚àß A`. Podemos pedirle a Agda que nos de m√°s informaci√≥n sobre nuestro
problema (Contexto y Meta) al posicionar el cursor en el hueco de meta
mediante la combinaci√≥n de teclas `C-c C-,` en emacs.

Veremos que ahora nos muestra mensajes muy distintos a los anteriores.
Nos dice que en nuestra declaraci√≥n del t√©rmino que necesitamos debemos asumir que
`B` y `A` son tipos. Quiz√°s para esta situaci√≥n no es muy reveladora la informaci√≥n
que brinda Agda, pero en otras situaciones brinda informaci√≥n bastante √∫til.

Podemos pedirle a Agda que nos de m√°s pistas, con base en la naturaleza de los
t√©rminos de los tipos que queremos producir. Para esto, de nuevo con el cursor en el hueco
de meta, presionamos la combinaci√≥n de teclas `C-c C-r` en emacs/vscode para "refinar la meta".

```haskell

‚àß-comm : {A B : Type} ‚Üí A ‚àß B ‚Üí B ‚àß A
‚àß-comm = Œª x ‚Üí {¬†}1

```

Al hacer esto, notamos que agda modifica el hueco y las metas se modifican acordemente.
Ahora nuestra meta es producir un t√©rmino de tipo `B ‚àß A`. Si volvemos a pedirle a Agda
el contexto y meta del problema, veremos que ahora tenemos a nuestra disposici√≥n
un t√©rmino `x : A ‚àß B`, con el cual podemos producir un t√©rmino de tipo `B ‚àß A`.
Si de nuevo le pedimos a Agda que refine la meta, tendremos ahora dos metas nuevas:
producir un t√©rmino de tipo `B` y otro t√©rmino de tipo `A`.

```haskell

‚àß-comm : {A B : Type} ‚Üí A ‚àß B ‚Üí B ‚àß A
‚àß-comm = Œª x ‚Üí {¬†}1 , {¬†}2

```

```haskell

‚àß-comm : {A B : Type} ‚Üí A ‚àß B ‚Üí B ‚àß A
‚àß-comm = Œª x ‚Üí {aa}0, {aa}1 

```

De aqu√≠, podemos proceder de al menos tres formas distintas.
  * Podemos recordar que en la teor√≠a de tipos de Martin-L√∂f (MLTT) el tipo producto
  es una noci√≥n primitiva, y por lo tanto Agda debe de implementar de forma "nativa"
  un eliminador izquierdo y derecho para el tipo producto.

  * Podemos probar un lema (redundante bajo la observaci√≥n anterior)
  * Podemos aprovechar las bondades de Agda y su pattern matching para poder construir el t√©rmino
  que queremos en virtud de la sintaxis que tienen los t√©rminos del tipo producto.

En tanto que para lo primero habr√≠a que irse a la documentaci√≥n de Agda, y podr√≠amos
usar lo tercero para probar el lema de la segunda opci√≥n, mejor probamos juntos el lema
y las otras opciones se quedan como ejercicio.

En MLTT, los t√©rminos del tipo producto se forman seg√∫n el siguiente juicio:

```haskell

Œì ‚ä¢ a : A      Œì ‚ä¢ b : B
--------------------------[√ó-intro]
Œì ‚ä¢ (a , b) : A √ó B

```

De esta forma, aprovechando el pattern matching de Agda podemos escribir la siguiente demostraci√≥n
para el lema

#### Lema

Sean $A$, $B$ proposiciones. Entonces $A ‚àß B ‚äÉ A$ y $A ‚àß B ‚äÉ B$.


##### Demostraci√≥n

```agda
‚àß-el : {A B : Type} ‚Üí A ‚àß B ‚Üí A
‚àß-el (a , b) = a

‚àß-er : {A B : Type} ‚Üí A ‚àß B ‚Üí B
‚àß-er (a , b) = b

```
Una observaci√≥n pertinete es que al refinar y obtener los dos huecos anteriormente,
Agda nos est√° diciendo que utilicemos la regla de introducci√≥n del tipo producto, tal y como
lo hicimos al probar nuestro lema, para generar el t√©rmino que deseamos. Entonces el proceso de
refinamiento de meta corresponde a aplicar una regla de introducci√≥n.

Ya armados con nuestro lema, podemos demostrar lo que quer√≠amos en un inicio.
Para "darle" a Agda los t√©rminos tenemos dos opciones, que realmente son la misma:
  * Escribir sobre el hueco el t√©rmino y luego presionar `C-c C-SPC` √≥,
  * Presionar sobre el hueco `C-c C-SPC`.

Antes de rellenar ambos huecos, prueba usando la combinaci√≥n `C-c C-n`
en alguno de los huecos, y escribiendo `‚àß-er x` o `‚àß-el x`. Encontrar√°s que Agda
**normaliza** el t√©rmino que escribiste. Al escribir `‚àß-er x` regresa `proj‚ÇÇ x` el cual
es el resultado de aplicar el eliminador "nativo" del tipo producto sobre el t√©rmino `x`.
Tras darle a Agda los t√©rminos necesarios, terminamos nuestra prueba. 

```agda

‚àß-comm : {A B : Type} ‚Üí A ‚àß B ‚Üí B ‚àß A
‚àß-comm = Œª x ‚Üí (‚àß-er x) , (‚àß-el x) 

```

En conclusi√≥n, el termino `‚àß-comm = Œª x ‚Üí (‚àß-er x) , (‚àß-el x)` es prueba/testigo de que
el tipo `‚àß-comm : {A B : Type} ‚Üí A ‚àß B ‚Üí B ‚àß A` no es vac√≠o y por lo tanto es una proposici√≥n
"verdadera".

Notemos que esta demostraci√≥n tiene su contraparte categ√≥rica.
# TODO: Insertar dibujin

Y tambi√©n tiene su contraparte en el c√°lculo de secuentes.
![secuentes conmut](./img/secuentes_comm.png)

#### Proposici√≥n

Sean $A, B$ proposiciones. Entonces $A ‚äÉ B ‚äÉ A$

##### Demostraci√≥n

```agda

prop1 : {A B : Type} ‚Üí A ‚Üí B ‚Üí A
prop1 = Œª a ‚Üí (Œª b ‚Üí a)

```

#### Proposici√≥n

Sean $A, B, C$ proposiciones. Si $A ‚äÉ B$ y $B ‚äÉ C$ entonces $A ‚äÉ C$.

##### Demostraci√≥n

```agda
-- Si uno tiene muchas ganas,
-- puede escribir la proposici√≥n en notaci√≥n de c√°lculo de secuentes

‚Üí-trans : {A B C : Type}
          ‚Üí (A ‚Üí B)
          ‚Üí (B ‚Üí C)
          ------------
          ‚Üí (A ‚Üí C)

‚Üí-trans f g = Œª a ‚Üí g (f a)
```
#### Proposici√≥n

Sea $A$ una proposici√≥n. Entonces $A ‚äÉ A$.

##### Demostraci√≥n

```agda
id : {A : Type} ‚Üí A ‚Üí A

id = Œª a ‚Üí a

```

#### Proposici√≥n

Sean $A, B$ proposiciones. Si $A ‚äÉ B$ y $A$, entonces $B$.

##### Demostraci√≥n

```agda
‚Üíapp : {A B : Type}
     ‚Üí (A ‚Üí B)
     ‚Üí A
     ----------------[App/Modus Ponens]
     ‚Üí B

‚Üíapp f a = f(a)
```

#### Proposici√≥n
Sea $A$ una proposici√≥n. Entonces $A ‚äÉ A ‚àß A$.

##### Demostraci√≥n

```agda

Œî : {A : Type}
  ‚Üí A
  -------------
  ‚Üí (A ‚àß A)


Œî a = id a , id a
```

#### Proposici√≥n
Sean $A, B, C$ proposiciones. Entonces $A √ó B ‚äÉ C$ si y solo si $A ‚äÉ B ‚äÉ C$
(Hom(A √ó B, C) ‚âÖ Hom(A, C·¥Æ))
##### Demostraci√≥n

```agda

currying : {A B C : Type}
          ‚Üí (A ‚àß B ‚Üí C)
          ----------------
          ‚Üí A ‚Üí B ‚Üí C
currying = Œª f ‚Üí Œª a ‚Üí Œª b ‚Üí f (a , b)

currying2 : {A B C : Type}
          ‚Üí (A ‚Üí B ‚Üí C)
          ----------------
          ‚Üí (A ‚àß B ‚Üí C)
currying2 = Œª f ‚Üí Œª ab ‚Üí (f (‚àß-el ab)) (‚àß-er ab) 

```

Podemos definir el si y solo si.

```agda

_‚áî_ : (A B : Type) ‚Üí Type 
A ‚áî B = (A ‚Üí B) ‚àß (B ‚Üí A)

```
#### Proposici√≥n

Sean $A, B, C$ proposiciones. Entonces $A ‚äÉ (B ‚àß C) ‚áî ((A ‚äÉ B) ‚àß (A ‚äÉ C)) 

##### Demostraci√≥n

Para probar una doble implicaci√≥n necesitamos dar una prueba de la ida y una prueba del regreso.
Para probar la ida podemos suponer que disponemos de un t√©rmino del tipo t‚ÇÅ : (A ‚Üí (B ‚àß C)) y
debemos construir un t‚ÇÇ : ((A ‚Üí B) ‚àß (A ‚Üí C)).
Para demostrar el regreso, debemos suponer que conamos con un t√©rmino t‚ÇÅ : ((A ‚Üí B) ‚àß (A ‚Üí C))
y construir un t‚ÇÇ : (A ‚Üí (B ‚àß C))

```agda
‚Üí-dist‚àß : {A B C : Type} ‚Üí (A ‚Üí (B ‚àß C)) ‚áî ((A ‚Üí B) ‚àß (A ‚Üí C))
‚Üí-dist‚àß = (Œª t‚ÇÅ ‚Üí                                            -- ‚äÉ )
                (Œª a ‚Üí ‚àß-el (t‚ÇÅ a)) , Œª a ‚Üí ‚àß-er (t‚ÇÅ a)) ,
          Œª t‚ÇÅ ‚Üí                                             -- ‚äÇ )
                Œª a ‚Üí (‚àß-el t‚ÇÅ) a , (‚àß-er t‚ÇÅ) a

```

### Disjunci√≥n

La disjunci√≥n es un tipo inductivo.

```agda
-- Cuando se tiene algo de la forma (A B : Type) estamos diciendole a Agda que queremos
-- explicitos los tipos. Cuando se tiene algo de la forma {A B : Type} le pedimos a agda
-- que infiera los tipos.

data _‚à®_ (A B : Type) : Type where
  left  : A ‚Üí A ‚à® B
  right : B ‚Üí A ‚à® B

```

Muchas veces, cuando un tipo suma est√° involucrado, es necesario separar por casos.
Esto se aprecia en la definici√≥n del tipo ‚à®, en tanto que un t√©rmino de dicho tipo
en principio puede tener dos formas: dicho t√©rmino pudo haber sido construido
mediante una aplicaci√≥n de `left`, o mediante una aplicaci√≥n de `right`. Por consiguiente,
debemos tomar en cuenta estos dos casos distintos en nuestras pruebas.

```agda

--{ Principio de demostraci√≥n por casos }--

caseof : {A B C : Type}
         ‚Üí (A ‚à® B)
         ‚Üí (A ‚Üí C)
         ‚Üí (B ‚Üí C)
         ----------------[‚à®-elim]
         ‚Üí C
 
caseof (left a‚à®b) c‚ÇÅ c‚ÇÇ = c‚ÇÅ a‚à®b     -- Caso 1. Ocurre A
caseof (right a‚à®b) c‚ÇÅ c‚ÇÇ = c‚ÇÇ a‚à®b    -- Caso 2. Ocurre B

```

#### Proposici√≥n

La disjunci√≥n es conmutativa.

##### Demostraci√≥n

```agda

‚à®-comm : {A B : Type} ‚Üí A ‚à® B ‚Üí B ‚à® A
‚à®-comm (left a‚à®b) = right a‚à®b
‚à®-comm (right a‚à®b) = left a‚à®b

```
#### Proposici√≥n

La disjunci√≥n distribuye sobre la conjunci√≥n.

##### Demostraci√≥n

```agda

‚à®-dist‚àß : {A B C : Type}
          ‚Üí (A ‚à® (B ‚àß C))
          -------------------
          ‚Üí (A ‚à® B) ‚àß (A ‚à® C)

‚à®-dist‚àß (left a‚à®[b‚àßc]) = left a‚à®[b‚àßc] , left a‚à®[b‚àßc] 
‚à®-dist‚àß (right a‚à®[b‚àßc]) = right (‚àß-el a‚à®[b‚àßc]) , right (‚àß-er a‚à®[b‚àßc])
```

### Negaci√≥n

En la l√≥gica proposicional, una proposici√≥n falsa es aquella que no se puede demostrar.
Por lo tanto, la definimos como tal.

```agda

data ‚ä• : Type where

```

Observa que no tiene constructor alguno. Por lo tanto no hay forma de construir un t√©rmino
de ‚ä•.

#### Principio de explosi√≥n

Si $A$ es una proposici√≥n, entonces $‚ä• ‚äÉ A$.

#### Demostraci√≥n

```agda

‚ä•-e : {A : Type}
      ‚Üí ‚ä•
      -------------
      ‚Üí A

‚ä•-e = Œª x ‚Üí {!!}
```

# TODO
> Mencionar a que aplicaci√≥n de juicios corresponden las combinaciones de teclas en agda
[Agda Docs](https://agda.readthedocs.io/en/v2.5.2/tools/emacs-mode.html)
